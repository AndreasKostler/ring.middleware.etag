* Selective browser caching with ETags in Clojure
An ETag is an opaque identifier assigned by a web server to a specific version of a resource found at a URL. 
If the resource content at that URL ever changes, a new and different ETag is assigned. 
Thus, ETags provide an efficient way of determining if two versions of a resource are the same or are different. 
A web-application can make use of this functionality to seriously reduce internet traffic by selectively enabling browser caches.

** How it works
A web server returns a resource along with its corresponding ETag value. A client may then decide to cache the resource, along with its ETag. 
Later, if the client wants to retrieve the same URL again, it will send its previously saved copy of the ETag along with the request in a "If-None-Match" field.
On this subsequent request, our server will compare the client's ETag with the ETag for the current version of the resource. If the ETag values match the server will send back a very short response with an HTTP 304 Not Modified status. 
However, if the ETag values do not match, meaning the resource has likely changed, then a full response including the resource's content is returned.

To summarise these steps:
- Client requests a page;
- Server sends back page + ETag;
- Client renders the page then caches it, along with the ETag;
- Client requests page again + ETag;
- Server examines the ETag; if the page hasn't changed since last request it sends back a status 304 response (Not Modified) with an empty body; otherwise it will send the changed content;

...Let's get started

** Compojure and Ring
This tutorial will make use of [[https://github.com/weavejester/compojure][Compojure]] to generate [[http://github.com/mmcgrana/ring/wiki][Ring]] handler functions and it is recommended that you read up on their usage first.
I will however give a (very) brief introduction to the main components of Compojure and Ring as relevant for this application. 
If you know Compojure/Ring already you can skip this section.
*** Handlers
HTTP requests and HTTP responses are represneted by clojure maps. A handler is a function that takes a request map as an argument and returns a response map:

#+begin_example
{ request } -> handler -> { response }
#+end_example

Here is an example of the a handler being turned into a servlet and 
passed to an embedded web server: 

#+begin_src clojure
  (ns example-app 
    (:use compojure.server.jetty)) 

  (defn hello-world [request] 
    {:status  200 
     :headers {} 
     :body    "Hello World"}) 

  (run-server {:port 8080} 
    "/*" (servlet hello-world)) 
#+end_src

*** Middleware

Middleware are functions that take a handler as its first argument, 
and return a new handler function based on the original:

#+begin_example
   handler & args --> middleware --> handler 
#+end_example

An example of a simple middleware function is one that adds a header 
to the output of a handler: 

#+begin_src clojure
  (defn with-header [handler header value] 
    (fn [request] 
      (let [response (handler request)] 
        (assoc-in response [:headers header] value))))
#+end_src 
  
To apply this to the existing `hello-world` handler, you can redefine 
`hello-world` with the middleware wrapper. 

#+begin_src clojure
  (def hello-world
    (-> hello-world
      (with-header "X-Lang" "Clojure") 
      (with-header "X-Framework" "Compojure")) 
#+end_src

*** Routes 

A route is a type of handler that returns nil if the request does 
not match certain criteria. A route can be written as a standard handler:

#+begin_src clojure
  (defn index-route [request] 
    (if (and (= (:request-method request) :get) 
             (= (:uri request) "/")) 
      {:status  200 
       :headers {} 
       :body    "The index page")) 
#+end_src

But as this is a very common task, Compojure provides macros that 
remove the need for such verbose boilerplate. The idiomatic way of 
writing the above route in Compojure is:
 #+begin_src clojure
  (def index-route 
    (GET "/" "The index page")) 
#+end_src

The Compojure route syntax is very powerful and what I presented above barely scratches the surface.
So, now that we have a black belt (*cough*) in Clojure-Web-Dev-Fu let's move on... 

** The App

First, let's create a basic web application displaying some content:

#+begin_src clojure
;;Display heading
(defn response [request]
  {:status 200
   :headers {}
   :body (str "<h1>Hello ETags World!</h1>")})
  
;; Create a basic index route 
(defroutes example1-app 
  (GET "/" request (response request)))
  
;; Run the server, {:join? false} runs the sever in its own thread returning immeadiately
(defonce server
  (run-jetty #'example1-app
             {:join? false
              :port 8080}))
#+end_src

If you now point your browser to http://localhost:8080/ you should see a web page displaying the above message.

*** Make it stick - Caching
The next step is to attach an ETag to the HTTP response. ETags are stored in the HTTP headers. We can easily create
middleware that adds an ETag to the response header:

#+begin_src clojure
  (def +global-etag+ "Clojure-etag")

  (defn create-etag [_]
    +global-etag+)

  (defn with-etag [handler etag-fn] 
    (fn [request]
      (let [response (handler request)]
        (assoc-in response [:headers "etag"] (etag-fn (:body response))))))
#+end_src

And decorate our response handler with the newly created middleware:

#+begin_src clojure
 (def response
   (-> response
       (with-etag :etag-fn etag-fn)))
#+end_src

Note that create-etag in this example returns a constant. Typically, create-etag would create an etag based on the request content, e.g. by hashing.

The next time the client sends a request, it will include a "if-non-match" field in its request header. 
We can display this by slightly altering our response handler:

#+begin_src clojure
(defn response [request]
  {:status 200
   :headers {}
   :body (str "<h1>Hello ETags World! - ETag is: " (get-in request [:headers "if-none-match"] "Ooops - no etag") "</h1>")})
#+end_src
If you refresh your browser after evaluating our new response function, you should see the stored etag displayed next to the welcome message.
The final step is to selectively re-send the content based on the stored ETag. A simple conditional check in response will do the trick:

#+begin_src clojure
  (defn with-etag [handler etag-fn] 
    (fn [request]
      (let [old-etag (get-in request [:headers "if-none-match"])
            response (handler request)
            new-etag (etag-fn response)]
        (if (= old-etag new-etag)
          {:status 304 :headers {} :body ""}
          (assoc-in response [:headers "ETag"] new-etag)))))
#+end_src 

This is it. As simple as that. While this example is not particulary sophisticated, ETags can be used for all sorts of interesting applications.
The full source for this example can be found [[https://github.com/AndreasKostler/ring.middleware.etag/blob/master/src/examples/src/examples/example1.clj][here]]. 

I encourage you to play with this simple app. Use your browsers debugging facilities to inspect the request/response headers.
For the full-fledged implementation of with-etag can be found [[https://github.com/AndreasKostler/ring.middleware.etag/blob/master/src/ring/middleware/etag/core.clj][here]].

In the remainder of this document I will show you how to use ETags for client side caching of javascript and caching of query results.

** Client side caching of JS.
Imagine your application serves javascript to transform the DOM of a third party page. Let's also imagine, that javascript is rather big and fairly static.
As visitor numbers increase, the operator of the third party page recently started complaining about network traffic and the delays caused by loading your js.
For applications like this it may makes sense to cache that JS on the client to reduce network traffic. We can easily do that using our ETags middleware.

Firstly, create a web-app representing the third-party page. I will use another powerful element of Clojures web-app stack: [[https://github.com/cgrand/enlive][Enlive]]. 
Enlive is a selector-based (Ã  la CSS) templating library for Clojure. Again, we're not even going to scratch the surface of its capabilities but it will
make our life a little easier.
And enlive template has two parts: 

1 Create a HTML file called template.html in your project-root/srt/etags_examples/template.html

#+begin_src html
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Static JS and ETags!</title>
	<script type="text/javascript" src="http://localhost:8888/static.js"></script>
    </head>
    <body>
        <p>ETags rock!</p>
        <p id="message">Default message.</p>
    </body>
</html>
#+end_src

2 Create a deftemplate:

#+begin_src clojure
(html/deftemplate index "etags_examples/template.html" [])
#+end_src

3 And now lets put the third party page together:

#+begin_src clojure
(defroutes third-party-app 
  (GET "/" [] (index)))

(defonce server
  (run-jetty
   #'third-party-app
   {:join? false
    :port 8080}))
#+end_src clojure

This is not particularly exciting but it serves our purpose. If you point your browser to http://localhost:8080 you should see a fairly bland webpage displaying
some heading and default content.

Let's move on to the more interesting bits :)

4 Create a file called big-static.js in your project root directory:

#+begin_src js
document.getElementById('message').innerHTML = 'Transmogrified message.';
#+end_src

5 Create the web-app serving the big-static JS:

#+begin_src clojure
(defroutes static-js-server 
  (GET "/big-static" [] (ring.response/file-response filename)))

(defonce server
  (run-jetty
   #'static-js-server
   {:join? false 
    :port 8888}))
#+end_src


Once our JS server goes 'online' you should see the message on our third-party page change after hitting reload.

So far there's no caching going on. Everytime we hit the page the third party page
will request our big-static JS. Using ETags for implementing caching is a trivial exercise:

#+begin_src clojure

;; The response ... add script tag here  
(defn response [request]
  {:status 200
   :headers {}
   :body (html [:h1 (str "Hello ETags World!")])}))

;; Create a index-route
(defroutes etags-app 
  (GET "/" request (response request)))
#+end_src

So far so good. Now lets add a create-etag function that creates an unique etag for our js

(defn create-etag [request]
  (let [js (:body request)]
(defonce server (run-jetty #'myroutes
  {:join? false
  :port 8080}))








HTML 

Last but not least, Compojure uses a syntax made up of vectors, maps and strings to 
represent HTML. The `html` function translates this syntax into a 
string of HTML. 
Here is an example of the syntax: 
  [:h1 {:id "title"} "Hello World"] 
In Compojure, this is referred to as a tag vector, so called because 
it represents a HTML tag. 
The first element in the vector is the tag name. This can be a 
keyword, a string, or a symbol. 
The second element can optionally be a map. If it is a map, it is 
considered to represent the attributes of the tag, otherwise it is 
treated as the tag's content.
 
Any further elements are treated as the content of the tag. A tag's 
content can be made up of any number of strings or nested tag vectors. 

Compojure also provides a shorthand for defining elements with id or 
class attributes, based on standard CSS syntax. Any alphanumeric, "-" 
or "_" after a "#" in the tag name is used as the id attribute: 
  [:h1#title "Compojure"] 
Similarly, any alphanumeric, "-" or "_" after a "." is used as the 
class attribute:
 
  [:div.summary "A Clojure web framework"] 

You can define many classes, but only one id using this syntax. 
  [:pre#example1.source.clojure 
    "(some example code)"] 

In my next blog post I will put ETags to use within a simple A/B Testing framework.
